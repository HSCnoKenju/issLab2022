
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Costruire software &#8212; iss22 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="RaspberrySoftware" href="RaspberrySoftware.html" />
    <link rel="prev" title="Introduzione" href="Introduzione.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="costruire-software">
<h1>Costruire software<a class="headerlink" href="#costruire-software" title="Permalink to this headline">¶</a></h1>
<p>Il software puo essere definito come:</p>
<ul class="simple">
<li><p>l’insieme di <em>frasi espresse in un qualche linguaggio formale</em> al fine di istruire un elaboratore
o una rete di elaboratori,</p></li>
</ul>
<p>Il <span class="blue">software non ha consistenza fisica</span>; può consumare energia ed altre risorse,
produrre effetti utili o dannosi, avere conseguenze rilevanti sul piano economico e sociale,
ma il software è del tutto privo di massa.</p>
<p>Le conseguenze di questa caratteristica sono molteplici, sia sul piano pragmatico che sul piano filosofico.
Limitando il discorso al contesto della produzione industriale, si è diffusa la convinzione che
la costruzione del software non richieda, per sua natura, processi di produzione tipici dell’ingegneria tradizionale.</p>
<a class="reference internal image-reference" href="_images/ScienzaEIng.PNG"><img alt="_images/ScienzaEIng.PNG" class="align-center" src="_images/ScienzaEIng.PNG" style="width: 60%;" /></a>
<section id="ingegneria">
<h2>Ingegneria<a class="headerlink" href="#ingegneria" title="Permalink to this headline">¶</a></h2>
<p>Nell’<strong>ingegneria tradizionale</strong> (meccanica, edile, etc) il costo del materiale costituisce spesso più del 50%
del costo totale di un progetto, mentre nella produzione del software è il costo del lavoro ad essere preponderante:
si parte dal 70% fino a giungere quasi al 100%.</p>
<p>L’ingegneria tradizionale ha anche sperimentato che un cambiamento
di costo 1 in fase di analisi potrebbe costare 1000 in fase di produzione.</p>
<p>Per questo l’ingegneria classica diversifica le fasi di produzione delineando un ben noto flusso di lavoro
(<em>workflow</em>) costituito da un insieme di passi (o tasks):</p>
<ol class="arabic simple">
<li><p>definizione dei requisiti,</p></li>
<li><p>analisi del problema,</p></li>
<li><p>progetto della soluzione,</p></li>
<li><p>realizzazione del prodotto,</p></li>
<li><p>collaudo</p></li>
<li><p>messa in opera</p></li>
</ol>
<p>spesso eseguiti uno dopo l’altro, in un classico <span class="blue">processo di sviluppo sequenziale o a cascata</span>.</p>
<a class="reference internal image-reference" href="_images/WaterFall.PNG"><img alt="_images/WaterFall.PNG" class="align-center" src="_images/WaterFall.PNG" style="width: 60%;" /></a>
</section>
<section id="programmatori-non-ingegneri">
<h2>Programmatori = (non) ingegneri?<a class="headerlink" href="#programmatori-non-ingegneri" title="Permalink to this headline">¶</a></h2>
<p>Nella produzione industriale del software è piuttosto comune cercare di abbattere i costi
di progetto e di sviluppo, anche limitando le dimensioni del gruppo di lavoro,
e aggredire il mercato prefissando una data di distribuzione del prodotto, che viene di frequente
rilasciato non completamente finito, accollando all’utente parte dell’onere di collaudo.</p>
<p>Sotto la spinta di stringenti vincoli di <em>time to market</em> (TTM) molte aziende adottano uno schema del tipo
<span class="blue">“scrivi, prova e correggi”</span>, mirando alla produzione di codice al minor “costo immediato” possibile.
Le <span class="blue">fasi di analisi e progetto</span> anche se accuratamente svolte, non sempre sono adeguatamente documentate,
e <em>quasi mai corralete in modo sistematico con il codice prodotto</em>.</p>
<p>Il processo di costruzione del sofware è quindi <span class="blue">influenzato da una potente forza</span>,
legata alla natura stessa del software: la spinta a impostare la costruzione di un prodotto in modo <strong>bottom-up</strong>,
a partire da una specifica tecnologia costituita da un linguaggio di programmazione,
o da un framework applicativo o da una piattafforma operativa.</p>
<a class="reference internal image-reference" href="_images/bottomUp.png"><img alt="_images/bottomUp.png" class="align-center" src="_images/bottomUp.png" style="width: 50%;" /></a>
<p>La principale conseguenza negativa di questa forza è molto spesso l’assenza di una esplicita descrizione di progetto
che permetta di anticipare la valutazione dei rischi e le potenziali difficoltà connesse allo sviluppo.
In molti casi adeguate fasi di analisi e di progettazione hanno luogo, anche in modo sistematico;
ma ciò putroppo quasi sempre accade solo nella mente dei costruttori;
nel codice finale non vi è più traccia alcuna di queste fasi, se non qualche debole segnale legato a sporadici commenti.</p>
<p>Tuttavia, anche se il codice fosse accuratamente documentato sia in relazione all’analisi sia in relazione
alle scelte di progetto, la <strong>riduzione del prodotto al solo codice sarebbe non accettabile</strong>,
se non nel caso di sistemi software semplici o di software molto ben fatto.</p>
<p>All’aumentare della complessità infatti, la <span class="blue">mente umana ha bisogno</span>,
per comprendere, di decomporre il problema in parti di ampiezza limitata,
<span class="blue">articolando la descrizione in livelli di astrazione diversi</span>;
poiché il codice deve inevitabilmente esprimere il sistema finale nei suoi minimi dettagli,
la maggior parte delle persone sarebbe incapace di leggerlo con profitto anche se a conoscenza
delle regole sintattiche del linguaggio di programmazione.</p>
<p>Per questo si parla spesso di modelli, che vengono espressi con opportuni linguaggi, spesso grafiici.</p>
<a class="reference internal image-reference" href="_images/Modello.PNG"><img alt="_images/Modello.PNG" class="align-center" src="_images/Modello.PNG" style="width: 50%;" /></a>
</section>
<section id="modelli">
<h2>Modelli<a class="headerlink" href="#modelli" title="Permalink to this headline">¶</a></h2>
<p>Nel linguaggio comune, il termine modello è spesso usato per denotare un’astrazione
di qualcosa che esiste nella realtà, come ad esempio il modello che posa per un artista,
una riproduzione in miniatura, un esempio di modo di svolgere un’attività, una forma
da cui ricavare vestiti, un ideale da seguire, etc..</p>
<p>Alcuni (tra cui gli ingegneri) intendono per modello un sistema matematico o fisico che ubbidisce
a specifici vincoli e che può essere utilizzato per descrivere e comprendere un sistema
(fisico, biologico, sociale, etc.) attraverso relazioni di analogia.</p>
<p>Nel contesto dei processi di costruzione del software, il termine modello va primariamente
inteso come un insieme di concetti e proprietà volti a catturare aspetti essenziali di un sistema,
collocandosi in un preciso spazio concettuale.</p>
<p>Per l’ingegnere del software quindi un modello costituisce una visione semplificata di un sistema
che rende il sistema stesso più accessibile alla comprensione e alla valutazione e facilita
il trasferimento di informazione e la collaborazione tra persone,
soprattutto quando è espresso in forma visuale.</p>
<a class="reference internal image-reference" href="_images/ModelloNumeri.PNG"><img alt="_images/ModelloNumeri.PNG" class="align-center" src="_images/ModelloNumeri.PNG" style="width: 50%;" /></a>
<p>Nel concepire un modello come visione semplificata di un sistema software si assume che il sistema
abbia già una sua esistenza concreta.
In alcune fasi di lavoro (in particolare nella fase di analisi) il sistema è il modello;
un raffinamento o una variazione del modello corrisponde in questo caso ad una variazione del sistema.</p>
<p>La produzione esplicita di modelli si rivela utile in quanto i diversi attori di un processo
di produzione di software (committenti, analisti, progettisti, utenti, etc)
operano a diversi livelli di astrazione.</p>
<p>Definendo opportuni modelli del sistema da realizzare, in ogni fase del processo di produzione
l’attenzione può essere focalizzata sugli aspetti rilevanti in quella fase, utilizzando una
forma di comunicazione comprensibile ad attori diversi.
Per garantire coesione e interoperabilità, si cerca di individuare regole di corrispondenza
e di trasformazione automatica tra modelli</p>
</section>
<section id="la-crisi-del-software">
<h2>La crisi del software<a class="headerlink" href="#la-crisi-del-software" title="Permalink to this headline">¶</a></h2>
<p>Impostare un processo di produzione in assenza di descrizioni del sistema che permettano di
<span class="blue">anticipare la valutazione dei rischi</span>
espone il processo stesso a un potenziale fallimento;
non meraviglia dunque che si senta spesso parlare di crisi del software.</p>
<p>La letteratura  (si veda ad esempio`SEDisasters`_) riporta casi di fallimento di un numero
sorprendentemente rilevante di progetti software, evidenziando un insieme di cause principali:</p>
<ul class="simple">
<li><p>Cattiva specifica e gestione dei requisiti.</p></li>
<li><p>Comunicazioni ambigue ed imprecise tra i diversi attori del processo di produzione
(utenti, manager, analisti, progettisti, implementatori).</p></li>
<li><p>Architetture finali del sistema fragili (non robuste).</p></li>
<li><p>Inconsistenze tra requisiti, progetto e realizzazione.</p></li>
<li><p>Collaudi inadeguati o insufficienti.</p></li>
<li><p>Inadeguata capacità di valutare e gestire i rischi e di controllare la propagazione dei cambiamenti.</p></li>
</ul>
<p>Queste potenziali fonti di insuccesso hanno amplificato la loro influenza nel momento in cui
l’intera disciplina ha vissuto la <span class="blue">transizione</span> da una dimensione prevalentemente <span class="blue">algorimtico-trasformazionale</span>
a un dimensione fortemente <span class="blue">sistemistico-architetturale</span>.</p>
</section>
<section id="richiami">
<h2>Richiami<a class="headerlink" href="#richiami" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="./NatMolBook/bookEntry.html">Dispense Ingegneria del software</a></p>
</section>
<section id="il-ruolo-dell-architettura">
<h2>Il ruolo dell’architettura<a class="headerlink" href="#il-ruolo-dell-architettura" title="Permalink to this headline">¶</a></h2>
<p>La moderna costruzione del software riconosce all’architettura del sistema un ruolo strategico,
nonostante il termine <em>architettura</em> sia tra i vocaboli più sovraccarichi di significato.</p>
<p>Normalmente, si parla di <span class="blue">architettura di un sistema</span> quando ci si vuole riferire all’insieme delle
macro-parti in cui il sistema si articola, includendo le loro responsabilità, relazioni e interconnessioni.</p>
<p>Per molti, il termine <em>architettura</em> potrebbe però evocare l’immagine di uno schema in cui compare una rete
di blocchi e linee di connessione; questa visione andrebbe meglio indicata col termine mappa o “topologia”.</p>
<p>Per altri, l’<em>architettura</em> evoca l’idea di uno schema concettuale di soluzione riferito a un certo dominio applicativo,
come ad esempio nella frase architetture web; in questo caso sarebbe più appropriato utilizzare il termine framework.</p>
<p>L’ Open Group Architectural Framework (<a class="reference external" href="https://it.wikipedia.org/wiki/The_Open_Group_Architecture_Framework">OpenGroupArch</a>) definisce architettura:</p>
<ul class="simple">
<li><p>“a set of elements depicted in an architectural model and a specification of how these elements are connected
to meet the overall requirements of an information system”.</p></li>
</ul>
<p>Altrove  si dice che:</p>
<ul class="simple">
<li><p>“the software architecture of a program or computing system is the structure
or structures of the system, which comprises software components, the externally-visible properties
of these components and the relationships among them”.</p></li>
</ul>
<p>La IEEE Computer society definisce (nel 2000) l’architettura:</p>
<ul class="simple">
<li><p>“the fundamental organization of a
system embodied in its components their relationships to each other and to the environment,
and the principles guiding its design and evaluation”.</p></li>
</ul>
<p>Tra le altre accezioni possibili, una delle più curiose, su cui vale la pena di riflettere, è quella per cui:</p>
<blockquote>
<div><ul class="simple">
<li><p>l’architettura è ciò che rimane di un sistema quando non si può più togliere nulla,
continuando a comprenderne la struttura e il funzionamento.</p></li>
</ul>
</div></blockquote>
<p>Le prime esperienze collettive nello studio delle architetture software possono essere fatte
risalire al workshop OOPSLA del 1981 guidato da Bruce Anderson che mirava allo sviluppo
di un “architecture handbook”.
A questo periodo può anche essere fatto risalire l’idea di <span class="blue">pattern</span> culminata nella pubblicazione
nel 1995 dell’ormai famoso testo sui <a class="reference external" href="https://it.wikipedia.org/wiki/Design_pattern">Design Pattern</a>  della così detta
<strong>GoF</strong> (<em>Gang-of-Four</em>: <em>Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides</em>).</p>
<a class="reference internal image-reference" href="_images/DesignPatternGof.PNG"><img alt="_images/DesignPatternGof.PNG" class="align-center" src="_images/DesignPatternGof.PNG" style="width: 60%;" /></a>
<p>Da allora si sono susseguiti molte altre conferenze e lavori.
I riferimenti più noti sono i cinque testi POSA sulle <em>Pattern Software Architectures</em>
e i convegni PLoP (<em>Pattern Languages of Programming</em>).</p>
<a class="reference internal image-reference" href="_images/Posa.PNG"><img alt="_images/Posa.PNG" class="align-center" src="_images/Posa.PNG" style="width: 60%;" /></a>
</section>
<section id="dimensioni">
<h2>Dimensioni<a class="headerlink" href="#dimensioni" title="Permalink to this headline">¶</a></h2>
<p>Sia nella fase di analisi che in quella di progetto, la descrizione di un sistema software può avvenire
focalizzando l’attenzione su almeno tre diversi punti di vista:</p>
<ul class="simple">
<li><p>l’organizzazione del sistema in parti (<strong>struttura</strong>);</p></li>
<li><p>il modo in cui le diverse parti scambiano informazione implicita o esplicita tra loro ((<strong>interazione(</strong>);</p></li>
<li><p>il funzionamento del tutto e di ogni singola parte ((<strong>comportamento(</strong>).</p></li>
</ul>
<a class="reference internal image-reference" href="_images/Dimensioni.png"><img alt="_images/Dimensioni.png" class="align-center" src="_images/Dimensioni.png" style="width: 60%;" /></a>
<p>Questi punti di vista costituiscono tre indispensabili dimensioni in cui articolare lo spazio della descrizione
del sistema, qualunque sia il linguaggio utilizzato per esprimere questa descrizione.
Costrutti per esprimere strutture (di dati e di controllo), forme di comportamento e meccanismi di interazione
sono presenti in tutti i linguaggi di programmazione.</p>
<p>Un punto importante consiste nel capire fino a che punto i costrutti di un linguaggio debbano influenzare
il progettista (se non lo stesso analista).
Fino alla fine degli anni 90 il linguaggio di programmazione è stato il veicolo principale per introdurre
nuovi concetti sia sul piano computazionale sia sul sul piano della organizzazione del software.</p>
<a class="reference internal image-reference" href="_images/historyHLPL.png"><img alt="_images/historyHLPL.png" class="align-center" src="_images/historyHLPL.png" style="width: 40%;" /></a>
<p>L’avvento della programmazione ad oggetti sembra avere segnato il culmine di questo processo;
un motivo può certo essere il raggiungimento di una sufficiente maturità nella capacità espressiva
in ciascuna delle dimensioni citate. Tuutavia, il motivo principale della relativa (apparente)
stagnazione nello sviluppo di nuovi linguaggi può essere ricondotto all’idea che un linguaggio
non deve essere necessariamente accompagnato da una sintassi concreta ma può essere suffciente
definire una sintassi astratta utilizzando un <span class="blue">meta-linguaggio</span> come ad esempio <code class="docutils literal notranslate"><span class="pre">MOF</span></code>
(si veda Meta Object Facility) unitamente alla semantica del linguaggio e a un framework (oo) di supporto.</p>
<a class="reference internal image-reference" href="_images/mofUml.PNG"><img alt="_images/mofUml.PNG" class="align-center" src="_images/mofUml.PNG" style="width: 60%;" /></a>
<p>Questa idea è sviluppata oggi con riferimento ai <em>Domain Specific Languages</em>.</p>
<section id="struttura">
<h3>Struttura<a class="headerlink" href="#struttura" title="Permalink to this headline">¶</a></h3>
<p>Per impostare in modo sistematico la definzione a livello strutturale di un elemento può essere conveniente,
sia in fase di analisi sia in fase di progetto, cercare di dare risposta ad alcune domande quali:</p>
<ul class="simple">
<li><p>l’elemento è <span class="blue">atomico o composto</span>? Nel caso sia composto quali sono le parti che lo formano?</p></li>
<li><p>l’elemento è dotato di <span class="blue">stato modificabile:</span>? In caso affermativo, quali sono le operazioni di modifica dello stato?
(si veda la sezione sul comportamento)</p></li>
<li><p>quali sono le <span class="blue">proprietà dell’elemento</span>, cioè quali attributi lo caratterizzano ?</p></li>
<li><p>da quali altri elementti dipende e secondo quale <span class="blue">tipo di dipendenza</span>?</p></li>
</ul>
<p>Si noti che un elemento composto implica la definizione ricorsiva della struttura di ogni parte e
la definizione di operazioni denominate selettori.
Notiamo anche che l’individuazione di una struttura composta porta spesso alla individuazione
di un insieme di operazioni primitive sulla base delle quali costruire ogni altra operazione
di manipolazione/gestione dell’elemento.</p>
</section>
<section id="interazione">
<h3>Interazione<a class="headerlink" href="#interazione" title="Permalink to this headline">¶</a></h3>
<p>Le interazioni possono essere sincrone o asincrone e riguardare informazioni o stream di dati.
In questo secondo caso esse possono essere anche isocrone.</p>
<p>In una interazione <strong>asincrona</strong>, la comunicazione è “bufferizzata” senza alcuna
limitazione sulle dimensioni del buffer.
L’emittente non deve attendere alcuna informazione di ritorno anche quando invia informazione
ad uno specifico destinatario. Il ricevente attende solo quando il buffer è vuoto.
Nel caso di stream, non vi sono vincoli di tempo per la ricezione.</p>
<p>In una interazione <strong>sincrona</strong>, la comunicazione avviene senza l’uso di alcun buffer.
L’emittente e il desinatario scambiano informazione unificando concettualmente le proprie attività.
Nel caso di stream, il destinatario si aspetta di ricevere i dati con un ritardo (delay)
che non supera un massimo prefissato.</p>
<p>Una interazione <strong>isocrona</strong> riguarda solo stream; il destinatario si aspetta di ricevere i dati
con un delay compreso tra un minimo e un massimo.</p>
<p>Le interazioni vengono spesso suddivise secondo quattro pattern principali:</p>
<ul class="simple">
<li><p><strong>Fire and forget</strong>: il caso di invio di  messaggi.</p></li>
<li><p><strong>Sync with server</strong>: il caso request-response.</p></li>
<li><p><strong>Poll objects</strong>: il sender invia una request delegando ad un oggetto (<em>poll object</em>) la responsabilità
di ricevere la risposta. Il sender usa il poll object per verificare ed acquisire la disponibilità della risposta.</p></li>
<li><p><strong>Result callback</strong>: il sender invia una request specificando un oggetto (<em>callback object</em>) che implementa
un metodo che verrà invocato dal supporto non appena il receiver invierà la risposta.</p></li>
</ul>
<p>Torneremo diffusamente su questi punti, che costituiscono il cuore del passaggio da OOP a message-passing.</p>
</section>
<section id="comportamento">
<h3>Comportamento<a class="headerlink" href="#comportamento" title="Permalink to this headline">¶</a></h3>
<p>Per esprimere il comportamento di un componente software, si distinguono classicamente tre diversi ‘stili’:</p>
<ul class="simple">
<li><p>imperativo</p></li>
<li><p>funzionale</p></li>
<li><p>logico-dichiarativo</p></li>
</ul>
<p>Spesso si fa anche riferimento a tipi diversi di macchine astratte, iniziando dalla Macchina di Turing (TM), che individua,
in stile imperativo, le moose elementari di un automa che permette di realizzare qualunque calcolo.</p>
<a class="reference internal image-reference" href="_images/TuringMachine.PNG"><img alt="_images/TuringMachine.PNG" class="align-center" src="_images/TuringMachine.PNG" style="width: 60%;" /></a>
<p>Un automa equivalente che ottiene lo stesso risultato con una sorta di linguaggio assembler minimale è la
Macchina di Minsky:</p>
<a class="reference internal image-reference" href="_images/MinskyMachine.PNG"><img alt="_images/MinskyMachine.PNG" class="align-center" src="_images/MinskyMachine.PNG" style="width: 60%;" /></a>
<p>Un tipo di automa meno potente, ma che avrà per noi un ruolo fondamentale è
l’automa a stati finiti (FSM) che costituisce una parte della TM.</p>
<p>Va sottolieata a questo punto la distanza tra le mosse elementari di base e quelle necessarie per affrontare
in modo adeguato un problema applicativo, una distanza cui faremo riferimento col termine <span class="blue">abstraction gap</span>.</p>
<a class="reference internal image-reference" href="_images/TopDownBottomUp.PNG"><img alt="_images/TopDownBottomUp.PNG" class="align-center" src="_images/TopDownBottomUp.PNG" style="width: 60%;" /></a>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo-unibo.gif" alt="Logo"/>
    
    <h1 class="logo logo-name">iss22</h1>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduzione.html">Introduzione</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Costruire software</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ingegneria">Ingegneria</a></li>
<li class="toctree-l2"><a class="reference internal" href="#programmatori-non-ingegneri">Programmatori = (non) ingegneri?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modelli">Modelli</a></li>
<li class="toctree-l2"><a class="reference internal" href="#la-crisi-del-software">La crisi del software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#richiami">Richiami</a></li>
<li class="toctree-l2"><a class="reference internal" href="#il-ruolo-dell-architettura">Il ruolo dell’architettura</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dimensioni">Dimensioni</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#struttura">Struttura</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interazione">Interazione</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comportamento">Comportamento</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RaspberrySoftware.html">RaspberrySoftware</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Introduzione.html" title="previous chapter">Introduzione</a></li>
      <li>Next: <a href="RaspberrySoftware.html" title="next chapter">RaspberrySoftware</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Antonio Natali.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/CostruireSoftware.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>